1. IntelliJ 실행    - 상단메뉴 -> [파일] -> [프로젝트 닫기]
2. [ 새 프로젝트 ]
	JAVA프로젝트 선택
	1. 이름 : tj2025A_web1(아무거나)
	2. 위치 : 바탕화면(아무곳이나)
		-> Git 저장소 생성 [x]체크안함
	3. 시스템빌드 : Gradle
		-> Gradle : 외부라이브러리 설치/세팅을 자동으로 해주는 소프트웨어
	4. JDK : 17
	5. Gradle : Groovy
	[생성]
3. Gradle 프로젝트 폴더구조
	.src폴더
	-> main폴더
	-> -> java폴더
4. 그레이들 프로젝트 환경에서 "MYSQL연동" 라이브러리 와 Spring 설치
	0. 접속 : https://start.spring.io/
	--왼쪽 화면--
	1. project : Gradle - Groovy
	2. Language : java
	3. Spring Boot : 3.5.4
	4. Project Metadata : 프로젝트 부가 정보[기본값]
	5. Packaging : Jar
	6. Java: 17
	--오른쪽 화면--
	7.  Dependencies( 프로젝트에 설치할 라이브러리 )
		1. [ Add dependencies... ] 클릭
		2-1. mysql 검색후 --> [MySQL Driver SQL] 선택
		2-2. Spring 검색후 --> [Spring Web Web ] 선택
    --하단에 화면--
	8. [ EXPLORE ] 클릭
		1. build.gradle 코드 복사후 내 프로젝트내 'build.gradle' 파일에 붙여넣기
		2. 오른쪽 상단에 코끼리(아이콘)새로고침 클릭 후

5. 웹 환경 설정
    1. AppStart 클래스 위에 @SpringBootApplication
    2. AppStart 클래스 내 main함수 안에서
        - SpringApplication.run( 현재클래스명.class);
        예] SpringApplication.run( AppStart.class);
    확인 : AppStart 클래스 실행후 브라우저에서 http://localhost:8080/ 접속
        " Whitelabel Error Page " : 문구가 나오면 정상
        " 사이트에 연결할 수 없음 " : 스프링 서버가 꺼져 있는 상태
    3. Dao 코드 유지 하고 Controller 클래스
    3-1 Controller 클래스명 위에 @RestController
    3-1 각 기능 메소드위에
        -저장 메소드(boardWrite) 위에 @PostMapping
        -조회 메소드(boardPrint) 위에 @GetMapping

제출 : 카카오톡방에 192.168.40.185:8080 주소 제출
컴퓨터 아이피 확인 : CMD -> ipconfig -> IPv4 주소 확인

[스프링 실행방법]
1. 폴더내 AppStart 클래스 생성
2. 클래스 위에 @SpringBootApplication
    --> 자동완성이 안될경우 : 그레이들 설정 안된상태
3. main 메소드 안에서
    SpringApplication.run( 현재클래스명.class );
4. 스프링 실행 전체코드
@SpringBootApplication
public class AppStart {
    public static void main(String[] args) {
        SpringApplication.run( AppStart.class );
    }
}
5. 스프링 실행
    주의할점 : console창에서 서버상태 혹은 복수실행 상태 확인.

6. 확인 : http://localhost:8080/
    정상화면 : Whitelabel Error Page
    비정상화면 :사이트에 연결할 수 없음

[ 스프링 ]
    1. 정의 : 스프링은 자바 기반의 엔터프라이즈 급 애플리케이션 개발을 위한 프레임워크
    2. 활용처 : 전자정부프레임워크( 대한민국 개발 표준 )
    3. 특징 : IOC/DI 객체의존성, AOP 로직분리 모듈(레고)화, MVC2 3tire 지원, 확장성
[ 스프링 부트 ]
    1. 스프링 프레임워크를 빠르게  사용할수 있도록 자동설정기반의 스타터 프레임워크
    2. 활용처 : 복잡한 설정을 제공 받는다.
    3. 특징 : ( 스프링부트 안에 스프링 포함 )
    4. 웹서버 : 내장 Tomcat 제공한다. Tomcat 이란? 자바 회사에서 만든 웹개발 관련 라이브러리 포함한 소프트웨어
        Starting Servlet engine: [Apache Tomcat/10.1.43]
[ 그레이들 ]
    1. 정의 : 그레이들은 자바 기반의 빌드 자동화 소프트웨어
    2. 특징 : 의존성 관리, 배포, 패키징 을 쉽게 코드 한줄로 자동 처리 해준다. ( 단 한국 라이브러리 없다 )
        dependencies {
            implementation 'org.springframework.boot:spring-boot-starter-web' // 스프링부트 웹 설치
            runtimeOnly 'com.mysql:mysql-connector-j' // MYSQL JDBC 라이브러리 설치
        }
[ 코드 ] : 명령어
[ 라이브러리 ] : 명령어들을 집합(메소드)해서 .jar 확장자로 만든 집합 , 미리 만들어진 코드 , 예] 도구 제공
[ 프레임워크 ] : 라이브러리 + 개발에 필요한 환경설정 까지, 예] 개발 틀 제공

[ REST ] : 웹의 자원을 관리하는 아키텍처/구조
    1. 자원(Resources) , 행동(Method) , 표현
    2. HTTP 프로토콜(규약) 이용한 클라이언트 와 서버 간의 일관성 통신 구성
[ REST API ] : REST 아키텍처에 따른 API
    1. REST 기반의 웹서비스 인터페이스 구축
    2. HTTP 요청을 통해 자원(데이터)을 C R U D 할 수 있도록 제공
[ RESTful API ]
    1. REST API 의 아키텍처를 잘 사용하는지 대한 개념
    2. 조건 :
        1. 일관성 : "/member/XXXX" , "/board/XXXX"
        2. 적절한 HTTP METHOD : POST(등록) , GET(조회) , PUT(수정) , DELETE(삭제)
        3. 무상태성
        4. 응답 타입은 JSON/ XML 제공

[ @ : 어노테이션 = 설명/방법 ]
    1. 정의 : 자바 및 Spring 에서 코드에 메타데이터를 추가하는 문법
    2. 목적 : 1.메타데이터 제공 2. 코드 간소화 3. 가독성 향상
    3. 종류
        1. 표준 어노테이션 : 자바에서 기본적으로 제공하는 어노테이션
            @Override : 상위 클래스로부터 메소드를 재정의을 설명 할때 사용
            @Deprecated : 더 이상 사용하지 않는 코드라고 설명 할때 사용
            등등
        2. 메타 어노테이션 : 코드를 정의하거나 동작 제어 할때 사용되는 어노테이션
            1. 서블릿(자바 웹클래스) 제공
            2. 스프링 회사 제공하는 @어노테이션

    4. 어노테이션 만들기
        1. @interface 어노테이션{  }
        2. 인터페이스 위에 다양한 @ 붙인다. 설정한다.
            @Retention( ) : 어노테이션 생성주기(유지기간)을 설정
                @Retention( RetentionPolicy.RUNTIME ) // 런타임(실행중)까지 유지 뜻
                @Retention( RetentionPolicy.CLASS ) // .class 파일에 포함 뜻 , 실행이 아닐때 유지 뜻
                @Retention( RetentionPolicy.SOURCE ) // 컴파일 이후에 삭제 한다는 뜻
            @Target( ) : 어노테이션 적용할 수 있는 위치(대상)을 설정
                @Target( ElementType.METHOD ) : 메소드에서 사용 뜻
                @Target( ElementType.TYPE ) : 클래스,인터페이스 등등 타입 사용 뜻
                @Target( ElementType.FIELD ) : 멤버변수 사용 뜻
                @Target( ElementType.PARAMETER ) : 매개변수  사용 뜻
                @Target( ElementType.CONSTRUCTOR ) : 생성자  사용 뜻

[ 메타데이터 ]
    1. 정의 : 코드를 설정하는 데이터 , 사용법 정의
    2. 목적 : 자바 코드에 *추가적인 데이터*를 주입/넣기 할때 사용
    3. 동작 구조 :
        1. 컴파일(번역) .java --> .class 파일 번역 하면서 바이트로 변환
        2. 리플렉션 : 런타임(실행중)에 클래스를 읽어와서 동적(할당)으로 객체 생성/조작
            Class.forName("com.mysql.cj.jdbc.Driver");
            - 프로그램 실행중 MYSQL 클래스 로드 함수. new Driver();
    3. 예] 스티커/라벨/설명서/태그 처럼 해당 코드를 사용하는 방법/부가 정보 *부착*

1. @SpringBootApplication : 스프링부트 환경 설정
    1) @SpringBootConfiguration : 프로젝트내 @Configuration 어노테이션을 찾아서 bean(객체) 설정/등록 할 수 있도록 설정
    2) @EnableAutoConfiguration : Spring Boot 가 자동으로 필요한 bean(객체)을 설정/등록. 웹서버인 내장형 TomCat 설정
    3) @ComponentScan : **** 현재클래스 기준으로 현 패키지 및 하위 패키지 **** 내 자동으로 컴포넌트(클래스) 들을 스캔해서 등록
        (1) 스캔 대상 : @Component @RestController @Controller @Service @Repository @Mapper 등등 주로 MVC 어노테이션
        (2) 주의할점 : 현재 AppStart 클래스 기준의 상위 패키지는 스캔 안되므로 프로젝트 항상 최상위 폴더에 위치한다.

2. @Component       : bean(객체) 자동으로 생성
3. @Controller      : HTTP(웹)통신 요청 과 응답(view) 처리 , + @Component
4. @RestController  : HTTP(웹)통신 요청 과 응답(json) 처리 , + @Controller + @ResponseBody
5. @PostMapping     : HTTP(웹)통신의 METHOD 중에 POST 방식으로 요청 매핑(연결) , 주로 Create
6. @GetMapping      : HTTP(웹)통신의 METHOD 중에 GET 방식으로 요청 매핑(연결) , 주로 Read
7. @PutMapping      : HTTP(웹)통신의 METHOD 중에 PUT 방식으로 요청 매핑(연결) , 주로 Put
8. @DeleteMapping   : HTTP(웹)통신의 METHOD 중에 DELETE 방식으로 요청 매핑(연결) , 주로 DELETE
   - @XXXXMapping( "/URL정의"): Mapping 어노테이션 (소괄호 안에서 정의할 웹주소(URL)을 baseURL(http://localhost:8080) 뒤로 사용할 주소 정의
   - @GetMapping("/member")  : "http://localhost:8080/member"
9. @ResponseBody        : HTTP(웹)통신의 요청 처리 이후 응답 반환시 *JAVA 타입에서 주로 JSON 타입으로 자동 변환 *
10. @RequestParam       : 쿼리스트링, GET/DELETE , 단일 매개변수   , int/String/List/Map
11. @ModelAttribute     : 쿼리스트링, GET/DELETE , 복수 매개변수   , DTO/VO
12. @RequestBody        : HTTP본문 , POST/PUT   , 본문 객체(JSON) , DTO/Map/List

[ HTTP 자료 포함 ]
    방법1. 쿼리스트링  ? URL 경로상의 매개변수 표현 , get/post/put/delete method 표현 , 매개변수 노출O
        예] http://localhost:8080/board ? mname = 유재석 & age = 10
    방법2. BODY(본문) ? HTTP BODY(본문)에 매개변수 표현 , post/put method 표현 , 매개변수 노출X
        예] http://localhost:8080
        F12[개발자도구] -> [네트워크] -> 지정 통신명 -> [페이로드]

[ Spring 정적파일 ]
    -> Spring 프로젝트내 HTML/CSS/JS/IMG 등등 파일
    -> src->main->resources-> static 폴더내
        --> 만약에 다른 폴더내 html/css/js/img 등 식별 불가능.
    1. Spring 프로젝트는 정해진 폴더(static)내 HTML 파일의 HTTP 경로 지원한다.
        http://localhost:8080/(static)이하 경로의 html
        예] http://localhost:8080/example/example1.html
    2. 지원확장자 : .html .js .css .jpg 등등 , 주로 정적파일이다.

[ Spring 동적파일 ]
    -> Spring 프로젝트내 JSP / *타임리프* / 머스테치 / REACT 등등 파일
        JSP 란 ? .jsp 파일내 java 와 html 코드를 모두 작성 가능한 확장자 : MVC1패턴(controller+view)
            -> 강의기준은 .jsp 파일 사용하되 특정기능만 사용, MVC2패턴( controller , view 분리 )
    -> 정적파일은 코드 그자체로 브라우저 해석(렌더링)  VS
    -> 동적파일은 코드 그자체로 브라우저 해석(렌더링)불가능, 각 프로그래밍언언어들 렌더링

[ Spring 과 JSP 통합 ]
    1. 문제점 : Spring 회사는 공식적인 JSP 지원하지 않는다.
    2. 설치방법 : 그레이들 환경
        1) build.gradle 파일내 jsp 의존성(dependencies) 추가 -> ctrl+shift+O(새로고침)
            implementation "org.apache.tomcat.embed:tomcat-embed-jasper"
        2) 패키지 구성
            1. 프로젝트 폴더내 ( src -> main -> webapp 폴더 생성 )
            2. webapp 폴더내 .jsp 파일 생성
                * 파일내 HTML 또는 JSP 코드 작성 , 인텔리제이 무료버전 자동완성 X -> VSCODE
            3. 모든 .jsp 파일 상단에 jsp 설정코드
                <%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
            * localhost:8080/(webapp)이하 경로 로 URL 정의된다.
            -> http://localhost:8080/test.jsp

        4) 다른 .jsp 파일 불러오기 , 헤더/푸터 페이지 사용된다.
            <jsp:include page="/.jsp경로"></jsp:include>
            * 주의할점 : 마크업간의 공백/띄어쓰기 사용하지 않기

[ 동기 vs 비동기 ] : 프로그래밍에서 작업 처리하는 방식
    동기란?    여러 작업이 실행될때 작업 간의 실행 순서를 제어 , 하나의 스레드가 동시에 접근 차단
        순차적처리, 느리다, 무결성 중시됨 예] 계좌이체:출금/입금
    비동기란?   여러 작업이 실행될때 독립적으로 실행 순서 , 하나의 스레드가 동시에 접근 허용
        동시처리, 빠르다, 무결성 보장안됨 예] 채팅

[ fetch ]
    1. 정의 : JS 에서 제공하는 내장 (통신) 함수
    2. 역할 : HTTP 요청을 보내고 응답을 비동기적으로 처리 함수
    3. 사용법
        [ 비동기 방법 ]
        fetch( url , option )
            .then( response => response.json() )
            .then( data => { } )
            .catch( error => { } )
    4.
        - url : Spring프로젝트내 통신할 controller 의 @XXXmapping 에서 정의된 URL
            주로 get/delete queryString : `url ? param1 = ${value1} & param2 = ${value}`
        - option :
            주로 get/delete : { method : "GET" } ,
            주로 post/put : { method : "POST" ,
                             headers : { "Content-Type" : "application/json"} ,
                             body : JSON.stringify( data )  }
        - then( 응답객체 => 응답객체.json() ) : 응답객체를 JSON 타입으로 변환
        - then( 변환된객체 => { 실행문 } );  : 통신 응답 결과
        - catch( 에러객체 => { 실행문 };     : 통신 에러 발생