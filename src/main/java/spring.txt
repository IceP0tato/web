1. IntelliJ 실행    - 상단메뉴 -> [파일] -> [프로젝트 닫기]
2. [ 새 프로젝트 ]
	JAVA프로젝트 선택
	1. 이름 : tj2025A_web1(아무거나)
	2. 위치 : 바탕화면(아무곳이나)
		-> Git 저장소 생성 [x]체크안함
	3. 시스템빌드 : Gradle
		-> Gradle : 외부라이브러리 설치/세팅을 자동으로 해주는 소프트웨어
	4. JDK : 17
	5. Gradle : Groovy
	[생성]
3. Gradle 프로젝트 폴더구조
	.src폴더
	-> main폴더
	-> -> java폴더
4. 그레이들 프로젝트 환경에서 "MYSQL연동" 라이브러리 와 Spring 설치
	0. 접속 : https://start.spring.io/
	--왼쪽 화면--
	1. project : Gradle - Groovy
	2. Language : java
	3. Spring Boot : 3.5.4
	4. Project Metadata : 프로젝트 부가 정보[기본값]
	5. Packaging : Jar
	6. Java: 17
	--오른쪽 화면--
	7.  Dependencies( 프로젝트에 설치할 라이브러리 )
		1. [ Add dependencies... ] 클릭
		2-1. mysql 검색후 --> [MySQL Driver SQL] 선택
		2-2. Spring 검색후 --> [Spring Web Web ] 선택
    --하단에 화면--
	8. [ EXPLORE ] 클릭
		1. build.gradle 코드 복사후 내 프로젝트내 'build.gradle' 파일에 붙여넣기
		2. 오른쪽 상단에 코끼리(아이콘)새로고침 클릭 후

5. 웹 환경 설정
    1. AppStart 클래스 위에 @SpringBootApplication
    2. AppStart 클래스 내 main함수 안에서
        - SpringApplication.run( 현재클래스명.class);
        예] SpringApplication.run( AppStart.class);
    확인 : AppStart 클래스 실행후 브라우저에서 http://localhost:8080/ 접속
        " Whitelabel Error Page " : 문구가 나오면 정상
        " 사이트에 연결할 수 없음 " : 스프링 서버가 꺼져 있는 상태
    3. Dao 코드 유지 하고 Controller 클래스
    3-1 Controller 클래스명 위에 @RestController
    3-1 각 기능 메소드위에
        -저장 메소드(boardWrite) 위에 @PostMapping
        -조회 메소드(boardPrint) 위에 @GetMapping

제출 : 카카오톡방에 192.168.40.185:8080 주소 제출
컴퓨터 아이피 확인 : CMD -> ipconfig -> IPv4 주소 확인

[스프링 실행방법]
1. 폴더내 AppStart 클래스 생성
2. 클래스 위에 @SpringBootApplication
    --> 자동완성이 안될경우 : 그레이들 설정 안된상태
3. main 메소드 안에서
    SpringApplication.run( 현재클래스명.class );
4. 스프링 실행 전체코드
@SpringBootApplication
public class AppStart {
    public static void main(String[] args) {
        SpringApplication.run( AppStart.class );
    }
}
5. 스프링 실행
    주의할점 : console창에서 서버상태 혹은 복수실행 상태 확인.

6. 확인 : http://localhost:8080/
    정상화면 : Whitelabel Error Page
    비정상화면 :사이트에 연결할 수 없음

[ 스프링 ]
    1. 정의 : 스프링은 자바 기반의 엔터프라이즈 급 애플리케이션 개발을 위한 프레임워크
    2. 활용처 : 전자정부프레임워크( 대한민국 개발 표준 )
    3. 특징 : IOC/DI 객체의존성, AOP 로직분리 모듈(레고)화, MVC2 3tire 지원, 확장성
[ 스프링 부트 ]
    1. 스프링 프레임워크를 빠르게  사용할수 있도록 자동설정기반의 스타터 프레임워크
    2. 활용처 : 복잡한 설정을 제공 받는다.
    3. 특징 : ( 스프링부트 안에 스프링 포함 )
    4. 웹서버 : 내장 Tomcat 제공한다. Tomcat 이란? 자바 회사에서 만든 웹개발 관련 라이브러리 포함한 소프트웨어
        Starting Servlet engine: [Apache Tomcat/10.1.43]
[ 그레이들 ]
    1. 정의 : 그레이들은 자바 기반의 빌드 자동화 소프트웨어
    2. 특징 : 의존성 관리, 배포, 패키징 을 쉽게 코드 한줄로 자동 처리 해준다. ( 단 한국 라이브러리 없다 )
        dependencies {
            implementation 'org.springframework.boot:spring-boot-starter-web' // 스프링부트 웹 설치
            runtimeOnly 'com.mysql:mysql-connector-j' // MYSQL JDBC 라이브러리 설치
        }
[ 코드 ] : 명령어
[ 라이브러리 ] : 명령어들을 집합(메소드)해서 .jar 확장자로 만든 집합 , 미리 만들어진 코드 , 예] 도구 제공
[ 프레임워크 ] : 라이브러리 + 개발에 필요한 환경설정 까지, 예] 개발 틀 제공


[ REST ] : 웹의 자원을 관리하는 아키텍처/구조
    1. 자원(Resources) , 행동(Method) , 표현
    2. HTTP 프로토콜(규약) 이용한 클라이언트 와 서버 간의 일관성 통신 구성
[ REST API ] : REST 아키텍처에 따른 API
    1. REST 기반의 웹서비스 인터페이스 구축
    2. HTTP 요청을 통해 자원(데이터)을 C R U D 할 수 있도록 제공
[ RESTful API ]
    1. REST API 의 아키텍처를 잘 사용하는지 대한 개념
    2. 조건 :
        1. 일관성 : "/member/XXXX" , "/board/XXXX"
        2. 적절한 HTTP METHOD : POST(등록) , GET(조회) , PUT(수정) , DELETE(삭제)
        3. 무상태성
        4. 응답 타입은 JSON/ XML 제공

1. @SpringBootApplication : 스프링부트 환경 설정
    1) @SpringBootConfiguration : 프로젝트내 @Configuration 어노테이션을 찾아서 bean(객체) 설정/등록 할 수 있도록 설정
    2) @EnableAutoConfiguration : Spring Boot 가 자동으로 필요한 bean(객체)을 설정/등록. 웹서버인 내장형 TomCat 설정
    3) @ComponentScan : **** 현재클래스 기준으로 현 패키지 및 하위 패키지 **** 내 자동으로 컴포넌트(클래스) 들을 스캔해서 *스프링컨테이너*등록
        (1) 스캔 대상 : @Component @RestController @Controller @Service @Repository 등등 주로 MVC 어노테이션
        (2) 주의할점 : 현재 AppStart 클래스 기준의 상위 패키지는 스캔 안되므로 프로젝트 항상 최상위 폴더에 위치한다.

2. @Component       : bean(객체) 자동으로 생성
3. @Controller      : HTTP(웹)통신 요청 과 응답(view) 처리 , + @Component
4. @RestController  : HTTP(웹)통신 요청 과 응답(json) 처리 , + @Controller + @ResponseBody
5. @PostMapping     : HTTP(웹)통신의 METHOD 중에 POST 방식으로 요청 매핑(연결) , 주로 Create
6. @GetMapping      : HTTP(웹)통신의 METHOD 중에 GET 방식으로 요청 매핑(연결) , 주로 Read
7. @PutMapping      : HTTP(웹)통신의 METHOD 중에 PUT 방식으로 요청 매핑(연결) , 주로 Put
8. @DeleteMapping   : HTTP(웹)통신의 METHOD 중에 DELETE 방식으로 요청 매핑(연결) , 주로 DELETE
   - @XXXXMapping( "/URL정의"): Mapping 어노테이션 (소괄호 안에서 정의할 웹주소(URL)을 baseURL(http://localhost:8080) 뒤로 사용할 주소 정의
   - @GetMapping("/member")  : "http://localhost:8080/member"

9. @RequestMapping  : HTTP (웹)통신의 주로 class 요청 매핑 , 즉] 공통 URL 정의
    - @RequestMapping("/member")
      class Controller{
        @GetMapping("/find")    <------ "/member/find"
      }

10. @ResponseBody        : HTTP(웹)통신의 요청 처리 이후 응답 반환시 *JAVA 타입에서 주로 JSON 타입으로 자동 변환 *
11. @RequestParam       : 쿼리스트링, GET/DELETE , 단일 매개변수   , int/String/List/Map
12. @ModelAttribute     : 쿼리스트링, GET/DELETE , 복수 매개변수   , DTO/VO
13. @RequestBody        : HTTP본문 , POST/PUT   , 본문 객체(JSON) , DTO/Map/List

[ HTTP 자료 포함 ]
    방법1. 쿼리스트링  ? URL 경로상의 매개변수 표현 , get/post/put/delete method 표현 , 매개변수 노출O
        예] http://localhost:8080/board ? mname = 유재석 & age = 10
    방법2. BODY(본문) ? HTTP BODY(본문)에 매개변수 표현 , post/put method 표현 , 매개변수 노출X
        예] http://localhost:8080
        F12[개발자도구] -> [네트워크] -> 지정 통신명 -> [페이로드]

[ Spring 정적파일 ]
    -> Spring 프로젝트내 HTML/CSS/JS/IMG 등등 파일
    -> src->main->resources-> static 폴더내
        --> 만약에 다른 폴더내 html/css/js/img 등 식별 불가능.
    1. Spring 프로젝트는 정해진 폴더(static)내 HTML 파일의 HTTP 경로 지원한다.
        http://localhost:8080/(static)이하 경로의 html
        예] http://localhost:8080/example/example1.html
    2. 지원확장자 : .html .js .css .jpg 등등 , 주로 정적파일이다.

[ Spring 동적파일 ]
    -> Spring 프로젝트내 JSP / *타임리프* / 머스테치 / REACT 등등 파일
        JSP 란 ? .jsp 파일내 java 와 html 코드를 모두 작성 가능한 확장자 : MVC1패턴(controller+view)
            -> 강의기준은 .jsp 파일 사용하되 특정기능만 사용, MVC2패턴( controller , view 분리 )
    -> 정적파일은 코드 그자체로 브라우저 해석(렌더링)  VS
    -> 동적파일은 코드 그자체로 브라우저 해석(렌더링)불가능, 각 프로그래밍언언어들 렌더링

[ Spring 과 JSP 통합 ]
    1. 문제점 : Spring 회사는 공식적인 JSP 지원하지 않는다.
    2. 설치방법 : 그레이들 환경
        1) build.gradle 파일내 jsp 의존성(dependencies) 추가 -> ctrl+shift+O(새로고침)
            implementation "org.apache.tomcat.embed:tomcat-embed-jasper"
        2) 패키지 구성
            1. 프로젝트 폴더내 ( src -> main -> webapp 폴더 생성 )
            2. webapp 폴더내 .jsp 파일 생성
                * 파일내 HTML 또는 JSP 코드 작성 , 인텔리제이 무료버전 자동완성 X -> VSCODE
            3. 모든 .jsp 파일 상단에 jsp 설정코드
                <%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
            * localhost:8080/(webapp)이하 경로 로 URL 정의된다.
            -> http://localhost:8080/test.jsp

        4) 다른 .jsp 파일 불러오기 , 헤더/푸터 페이지 사용된다.
            <jsp:include page="/.jsp경로"></jsp:include>
            * 주의할점 : 마크업간의 공백/띄어쓰기 사용하지 않기

[ 동기 vs 비동기 ] : 프로그래밍에서 작업 처리하는 방식
    동기란?    여러 작업이 실행될때 작업 간의 실행 순서를 제어 , 하나의 스레드가 동시에 접근 차단
        순차적처리, 느리다, 무결성 중시됨 예] 계좌이체:출금/입금
    비동기란?   여러 작업이 실행될때 독립적으로 실행 순서 , 하나의 스레드가 동시에 접근 허용
        동시처리, 빠르다, 무결성 보장안됨 예] 채팅

[ fetch ]
    1. 정의 : JS 에서 제공하는 내장 (통신) 함수
    2. 역할 : HTTP 요청을 보내고 응답을 비동기적으로 처리 함수
    3. 사용법
        [ 비동기 방법 ]
        fetch( url , option )
            .then( response => response.json() )
            .then( data => { } )
            .catch( error => { } )
    4.
        - url : Spring프로젝트내 통신할 controller 의 @XXXmapping 에서 정의된 URL
            주로 get/delete queryString : `url ? param1 = ${value1} & param2 = ${value}`
        - option :
            주로 get/delete : { method : "GET" } ,
            주로 post/put : { method : "POST" ,
                             headers : { "Content-Type" : "application/json"} ,
                             body : JSON.stringify( data )  }
        - then( 응답객체 => 응답객체.json() ) : 응답객체를 JSON 타입으로 변환
        - then( 변환된객체 => { 실행문 } );  : 통신 응답 결과
        - catch( 에러객체 => { 실행문 };     : 통신 에러 발생

[롬복] lombok
    1. 정의 : 반복되는 코드들을 줄여주는 라이브러리(미리 만들어진코드)
    2. 목적 : DTO, VO , ENTITY 에서 주로 사용된다.
        - DTO : data transfer object 데이터 (레이어간의)이동 객체
        - VO : value object 데이터 값을 가진 객체 (*읽기모드/setter없음)
        - ENTITY : 개체(실재/본체) 데이터의 실제 ( 주로 DB 레코드 뜻 )
    3. 설치
        1] (환경)인텔리제이 설치 : [파일] -> [설정] -> [플러그인] -> lombok 검색 -> 설치
        2] (프로젝트)그레이들 설치 :
              1. https://start.spring.io/
              2. 디펜더시 에서 'lombok' 검색
              3. 'build.gradle' 파일내 dependencies{} 추가.
                 compileOnly 'org.projectlombok:lombok'
                 annotationProcessor 'org.projectlombok:lombok'

[ 롬복 주요 어노테이션 ]
    1. @NoArgsConstructor           : 디폴트(기본) 생성자 코드 생성
    2. @AllArgsConstructor          : 모든 매개변수 생성자 코드 생성
        -> 몇몇 라이브러리 들이 필수로 사용됨.
            - @RequestXXXX 들이 매개변수를 자동 매핑
    3. @Getter                      : 멤버변수의 getter 메소드 코드 생성
    4. @Setter                      : 멤버변수의 setter 메소드 코드 생성
        -> setter and getter : private 멤버변수에 대해 외부 간접 접근 위해서
    5. @ToString                    : 객체 출력시 *주소값* 대신에 멤버변수 값을 *문자열*로 반환
        -> 주로 개발자가 console에 객체 정보 확인차

    * 어노테이션이란? @ 함으로써 바로 기능이 주입되는 방식이 아닌 프로젝트가 컴파일(실행) 될때 혹은 리플렉션(실행중) 될때 부가코드가 실행된다.
        -> 프로젝트폴더내 -> build 폴더 에서 확인가능

[ IOC ] : Inversion Of Control , 제어 의 역전
    1. 정의 : 객체의 생성 및 관리의 *제어권*을 개발자가 아닌 스프링 프레임워크가 담당한다.
    2. 스프링에서는 **컨테이너** 가 이를 담당한다.
    3. 목적 : 효율적이고 규칙적인 객체를 관리/사용 하기 위해서 스프링이 이를 대신한다.
        - 왜? 여러 사람들이 비규칙적인 객체를 사용하면 중복적인 객체 혹은 객체 충돌 발생할 수 도 있다.
    3. 주요 어노테이션
        @Component : 컨테이너(스프링 메모리/저장소) 에 클래스의 (빈bean)정보를 등록한다.
        ( @Component 내장된 주요 어노테이션 )
            - @Controller @RestController @Service @Repository @Configuration 등등
            - 각기 다른 기능들과 @Component가 내장 됨.
            - 주로 MVC 패턴 빈 등록한다. 즉] MVC 패턴은 IOC 기반 이면서 스프링의 필수 패턴!

[ DI ] : Dependency Injection : 의존성 주입
    1. 정의 : 객체를 직접 생성하지 않고 외부(스프링 컨테이너)로 부터 주입받도록 하는 방법
    2. 목적 : 객체들간의 결합도(관계)를 낮추고 유지보수성을 향상
    3. 주요 어노테이션
        @Autowired : 스프링 *컨테이너에 등록* 된 빈(객체)를 꺼내온다.
    4. 사용법
        1) 멤버변수(필드)에 주입
            @Autowired 클래스명 변수명;

        2) 생성자 에 주입 *권장(final이란? 수정불가능키워드/초기값필수)
            final 클래스명 변수명;
            @Autowired
            public 클래스명( 클래스명 매개변수명 ){ this.변수명 = 매개변수명; }

        3) Setter 를 이용한 주입
            클래스명 변수명;
            @Autowired
            public void set변수명( 클래스명 매개변수명 ){ this.변수명 = 매개변수명; }


* 즉] 싱글톤 대신에 사용 가능하다. 즉] DTO 는 싱글톤이 없었으므로 IOC/DI 와 상관없다.

                        [IOC]

--스프링 컨테이너--
|               |
|               |
| boardControl  | ----- @Autowired-------> boardControl 객체 꺼내기
|               |
|----------------

[ MVC 패턴 ]
    1. 정의 : 소프트웨어 공학에서 사용되는 디자인 패턴 중 하나
    2. 목적 : 프로그램을 깔끔하고 효율적으로 만들기 위한 설계 방법
    3. 종류
        1] MVC1         : controller/view <--> model
            -> JSP 파일에서 HTML 과 JAVA를 한번에 작성
            -> 장점 : 빠른개발 , 단점 : 유지보수/역할분담 힘듬

        2] MVC2         : view <--> controller <--> model
            -> view 파일은 HTML 만 작성 , controller 에서는 제어(로직)인 JAVA만 작성
            -> 장점 : 화면/로직 분리 , 단점 : 파일의 수 관리/증가

        3] MVC2 3Tire   : view <--> controller <--> service <--> model
            -> Spring MVC 에서 사용되는 패턴 , controller 의 역할 (제어 와 로직) 분리
            -> 장점 : 관점지향프로그래밍 특화 / 역할분담 / 유지보수 , 단점 : 파일 수 관리/증가

    4. 구역/레이어 종류
        1] VIEW : JSP/타임리프/머스테치/REACT ( HTML , CSS , JS )
            -> 역할 : 프론트엔드(화면구현)
            -> Spring 프로젝트에서는 resources 폴더에서 찾는다. *JSP는 webapp 폴더 에서 찾는다*

        2] CONTROLLER : @RestController @Controller
            -> 역할 : [주] HTTP 통신(요청/응답) , 매개변수/반환 타입 관리 변환 , VIEW 와 SERVICE 중계

        3] SERVICE : @Service
            -> 역할 : 비지니스로직( 기능에 있어서 실질적인 중요 코드)
            -> CRUD , 데이터 검증 , 연산 , 알고리즘 , *트랜잭션* 등 , SQL 제외한 실질적인 로직

        4] Repository : @Repository
            -> 역할 : 저장소( 실질적인 저장소/엔티티 를 조작코드 ) , DAO , ** JPA, myBatis **

* 유효성검사(유지보수단계에서도 계속) 위치 : JS , CONTROLLER , SERVICE , SQL

* 콘솔에 사이드 메뉴중에 최상단 메시지를 클릭하여 위에서부터 'ERROR' 메시지 이하 확인
1) 스프링서버는(AppStart) 2개 이상 실행 안됨.
    - port(프로그램 네트워크 식별번호:프로그램당 1개) 중복이다.
    (1) 현재 실행중인 AppStart 명 확인
    (2) Web server failed to start. Port 8080 was already in use.
        - 간혹 port 자동 종료가 안되는경우
        방법1) 컴퓨터 재시작
        방법2) 직접 port 끄기 , cmd -> 'netstat -ano'
            ->  0.0.0.0:8080 의 오른쪽 PID 확인한다.
            -> 'taskkill /f /pid [PID]'    예] taskkill /f /pid 6420

2) 스프링에서 resources 폴더와 webapp 폴더는 모든 AppStart 가 공유한다.
3) JSP는 무조건 webapp 폴더 내 자료(JSP/CSS/JS/IMG 등등)만 사용 가능하다.
4) 프론트엔드 코드(JSP/CSS/JS) 들은 일부(조금)만 수정 할 경우 브라우저 식별 안되므로 브라우저 강력새로고침 한다.
    단축키 : Ctrl + Shift + R 또는 Ctrl + F5
5) 모든 프로그래밍 언어들은 키워드(미리만들어진단어)로 변수명/함수명/클래스명 안됨.
    1. **JAVA는 키워드 오류 바로 발생**
    2. **JS는 키워드 오류 바로 발생 : CONSOLE확인**